## 一、重载和重写的区别

重载:

* 发生在同一个类中，**方法名必须相同，参数类型不同、个数不同、顺序不同**，方法返回值和访问修饰符可以不同，发生在编译时。

重写:

* 发生在父子类中，方法名、参数列表必须相同，**返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类**；如果父类方法访问修饰符为private，则子类就不能重写该方法。

## 二、String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的

简单的来说：String 类中使用 final 关键字字符数组保存字符串，`private final char value[]`，所以 String 对象是不可变的。而 StringBuilder 与StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value **但是没有用 final 关键字修饰**，所以
这两种对象都是可变的。

```java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;
    /**
     * This no-arg constructor is necessary for serialization of subclasses.
     */
    AbstractStringBuilder() {
    }
}
```

线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。

AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、 append、 insert、 indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全
的。
性能 : **每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的String 对象**。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

对于三者使用的总结：

1. 操作少量的数据 = String
2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer

## 三、在一个静态方法内调用一个非静态成员为什么是非法的

当New 一个对象的时候，并不是先在堆中为对象开辟内存空间，而是先将类中的静态方法（带有static修饰的静态函数）的代码加载到一个叫做方法区的地方，然后 再在堆内存中创建对象。

**所以说静态方法会随着类的加载而被加载**。当你new一个对象时，该对象存在于对内存中，this关键字一般指该对象，但是如果没有 new对象，而是通过类名调用该类的静态方法也可以。

静态方法是属于类的，动态方法属于实例对象，在类加载的时候就会分配内存，可以 通过类名直接去访问，非静态成员（变量和方法）属于类的对象，所以只有在对象实例化之后才存在，然后通过类的对象去访问。

**在一个类的静态成员中去访问非静态成员之所以会出错是因为在类的非静态成员不存在的时候静态成员就已经存在了，访问一个内存中不存在的东西当然会出错**。

## 四、在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行子类的构造方法之前，如果没有用 `super()` 来调用父类特定的构造方法，则会调用父类中“ 没有参数的构造方法” 。

因此，**如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误**，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。

解决办法是在父类里加上一个不做事且没有参数的构造方法。

## 五、成员变量和局部变量的区别

(1)、从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；

成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；

但是，成员变量和局部变量都能被 final 所修饰；

(2)、从变量在内存中的存储方式来看，成员变量是对象的一部分，**而对象存在于堆内存，局部变量存在于栈内存**。

(3)、**从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在**，而局部变量随着方法的调用而自动消失。

(4)、成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

## 六、对象实体与对象引用有何不同?

new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）; 

一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）

## 七、对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

## 八、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?

帮助子类做初始化工作。

## 九、hashCode 与 equals（重要）

(1)、hashCode（）介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据"键"快速的检索出对应的 "值 "。这其中就利用到了散列码！（可以快速找到所需要的对象）

(2)、为什么要有 hashCode?

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode， HashSet 会假设对象没有重复出现。

**但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功**。如果不同的话，就会重新散列到其他位置，这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

(3)、hashCode（）与 equals（）的相关规定

如果两个对象相等，则 hashcode 一定也是相同的

两个对象相等, 对两个对象分别调用 equals 方法都返回 true

**两个对象有相同的 hashcode 值，它们也不一定是相等的，因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，hashCode() 的默认行为是对堆上的对象产生独特值**。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 十、简述线程，程序、进程的基本概念

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，**一个进程就是一个执行中的程序**。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于**基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响**。