# 操作系统总结 - 进程同步、通信、死锁(三)

* [一、什么是进程同步、进程互斥](#一什么是进程同步进程互斥)
* [二、进程互斥的软件实现方法](#二进程互斥的软件实现方法)
* [三、进程互斥的硬件实现方法](#三进程互斥的硬件实现方法)
* [四、信号量机制](#四信号量机制)
* [五、用信号量实现进程互斥、同步、前驱关系](#五用信号量实现进程互斥同步前驱关系)
* [六、生产者-消费者问题](#六生产者-消费者问题)
* [七、多生产者-多消费者](#七多生产者-多消费者)
* [八、吸烟者问题](#八吸烟者问题)
* [九、读者-写者问题](#九读者-写者问题)
* [十、哲学家进餐问题](#十哲学家进餐问题)
* [十一、管程](#十一管程)
* [十二、死锁的概念](#十二死锁的概念)
* [十三、死锁的处理策略—预防死锁](#十三死锁的处理策略—预防死锁)
* [十四、死锁的处理策略—避免死锁(银行家算法)](#十四死锁的处理策略—避免死锁(银行家算法))
* [十五、死锁的处理策略—死锁的检测与解除](#十五死锁的处理策略—死锁的检测与解除)

***

## 一、什么是进程同步、进程互斥

**基本定义**:

* 进程具有异步性的特征，异步性是指 : 各并发执行的进程以各自独立的、不可预知的速度向前推进(之前提到)；
* 进程同步：指<font color = red>相互合作去完成相同的任务的进程间，由同步机构对执行次序进行协调</font>。(在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。)；
* 进程互斥：<font color = red>指多个进程在对临界资源进行访问的时候，应采用互斥方式；</font>
* 简单来说，同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。

**进程同步**

![1564994152870](assets/1564994152870.png)

**进程互斥**

![1565056520103](assets/1565056520103.png)

![1565056546358](assets/1565056546358.png)

**本节小结**:

![1565056643566](assets/1565056643566.png)

***
## 二、进程互斥的软件实现方法
![1565152593960](assets/1565152593960.png)

![1565158406242](assets/1565158406242.png)

![1565158785659](assets/1565158785659.png)

![1565159124556](assets/1565159124556.png)

![1565159426132](assets/1565159426132.png)

**本节小结**

![1565160868370](assets/1565160868370.png)

***
## 三、进程互斥的硬件实现方法
主要有三种:

* 中断屏蔽方法；
* TestAndSet( TS指令 / TSL指令)
* Swap指令 (XCHG指令)

![1565162005635](assets/1565162005635.png)

![1565162107623](assets/1565162107623.png)

![1565162127265](assets/1565162127265.png)

**本节小结**

![1565162668815](assets/1565162668815.png)

***
##  四、信号量机制(`important`)
**知识总览以及问题引入**

![1565162970457](assets/1565162970457.png)

**两种信号量机制:整型(`S`是一个整形变量)和记录型(`S`在一个结构体中)**

![1565163194994](assets/1565163194994.png)

![1565163666787](assets/1565163666787.png)

**下面看一个栗子的运行过程(重点)**

**①初始化**

![1565164013902](assets/1565164013902.png)

**②、③ 分别给`P1`进程和`P2`进程分配资源，使得`S.value = 0`**

![1565164532538](assets/1565164532538.png)

**此时为`P3`、`P4`进程服务，但是剩余资源数为`S.value = -2`，所以只能进入等待队列** 

![1565164569520](assets/1565164569520.png)

**所以`CPU`接下来只能为`P1`、`P2`服务，此时服务完之后调用 `signal`并`wake up`在等待队列中的`P3`、`P4`(每次空闲一个就唤醒等待队列中的一个)**(下图只画出将`P2`从队列中抽取出来，最后`P3`的过程也是一样的)

![1565164590125](assets/1565164590125.png)

![1565164628137](assets/1565164628137.png)

**本节小结**

![1565165120404](assets/1565165120404.png)

***
## 五、用信号量实现进程互斥、同步、前驱关系

信号量机制:

* 实现进程互斥
* 实现进程同步
* 实现进程的前驱关系

![1565166566230](assets/1565166566230.png)

![1565166589754](assets/1565166589754.png)

![1565166740562](assets/1565166740562.png)

**本节小结**

![1565168502229](assets/1565168502229.png)

***
## 六、生产者-消费者问题

![1565171779448](assets/1565171779448.png)

![1565232898568](assets/1565232898568.png)

![1565243526838](assets/1565243526838.png)

![1565243555856](assets/1565243555856.png)

**本节小结**

![1565244484013](assets/1565244484013.png)

***
## 七、多生产者-多消费者

![1565244574886](assets/1565244574886.png)

![1565244775230](assets/1565244775230.png)

![1565244877245](assets/1565244877245.png)

![1565244904870](assets/1565244904870.png)

![1565244983630](assets/1565244983630.png)

**本节小结**

![1565245006118](assets/1565245006118.png)

***
## 八、吸烟者问题
![1565245873940](assets/1565245873940.png)

![1565245928917](assets/1565245928917.png)

![1565246079236](assets/1565246079236.png)

![1565246102396](assets/1565246102396.png)

***
## 九、读者-写者问题
![1565246328994](assets/1565246328994.png)

![1565246439260](assets/1565246439260.png)

![1565246591452](assets/1565246591452.png)

代码实现: 

```c
Rcount = 0; // 当前有几个读进程在访问文件
semaphore CountMutex = 1;// 用于保证对count变量的互斥访问
semaphore WriteMutex = 1; // 用于实现对文件的互斥访问(写操作)

void writer(){
    while(true){
        sem_wait(WriteMutex);// P
        // TO DO write();
        sem_post(WriteMutex);// V
    }
}

// 读者优先策略
void reader(){
    while(true){
        sem_wait(CountMutex); //P
        if(Rcount == 0) // 第一个进程负责加锁
            sem_wait(WriteMutex);
        Rcount++;
        sem_post(CountMutex); //V
        
        // TO DO read();

        sem_wait(CountMutex);
        Rcount--;  // 访问文件的读进程数-1
        if(Rcount == 0)
            sem_post(WriteMutex); // 最后一个进程负责解锁
        sem_post(CountMutex);
	}
}
```
**防止写进程饿死的方法**:

![1565246913387](assets/1565246913387.png)

**本节小结**

![1565246929714](assets/1565246929714.png)

***
## 十、哲学家进餐问题
![1565247091643](assets/1565247091643.png)

![1565247115868](assets/1565247115868.png)

```c
//一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，
//那么就无法拿起右手边的筷子，造成死锁。

#define N 5		   // 哲学家个数
void philosopher(int i)  // 哲学家编号：0 － 4
{
    while(1)
    {
        think();			    // 哲学家在思考
        take_fork(i);			// 去拿左边的叉子
        take_fork((i + 1) % N);	// 去拿右边的叉子
        eat();				//　吃饭
        put_fork(i);			// 放下左边的叉子
        put_fork((i + 1) % N);	// 放下右边的叉子
    }
}
```

三种方案

![1565247986227](assets/1565247986227.png)

**第三种方案实现**

![1565248038259](assets/1565248038259.png)

为了防止死锁的发生，可以设置两个条件（临界资源）：
* 必须同时拿起左右两根筷子；
* 只有在两个邻居都没有进餐的情况下才允许进餐。

实现思路: 
```c
//1. 必须有一个数据结构，来描述每个哲学家当前的状态
#define N 5
#define LEFT i // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态

//2. 该状态是一个临界资源，对它的访问应该互斥地进行
semaphore mutex = 1;         // 临界区的互斥,互斥初始值一般是1

//3. 一个哲学家吃饱后，可能要唤醒邻居，存在着同步关系
semaphore s[N];    // 每个哲学家一个信号量

void philosopher(int i) {
    while(1) {
        think(); // 思考
        take_two(i); // 拿起两个筷子
        eat();
        put_tow(i);
    }
}

//拿走两只筷子
void take_two(int i) {
    P(&mutex);  // 进入临界区

    state[i] = HUNGRY; // 我饿了
    try(i); // 试图拿两只筷子

    V(&mutex); // 退出临界区
    P(&s[i]); // 没有筷子便阻塞
}

//放回两只筷子
void put_tow(i) {
    P(&mutex);

    state[i] = THINKING;
    try(LEFT); // 左边的人尝试
    try(RIGHT); //右边的人尝试

    V(&mutex);
}

void try(i) {         // 尝试拿起两把筷子
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        V(&s[i]); // 通知第i个人可以吃饭了
    }
}
```

**本节小结**
* 哲学家问题关键在于解决进程死锁；
* 这些进程之间只存在互斥关系，但是和之前的互斥关系不同的是: 每个进程都需要同时持有两个临界资源，因此有死锁的可能； 
***
## 十一、管程(高级同步机制)
**基本总结**

* 为什么要引入管程
* 管程的定义和基本特征
* 拓展1: 用管程解决生产者消费者问题
* 拓展2: Java中类似管程的机制

**引入**

![1565248774361](assets/1565248774361.png)

![1565248808896](assets/1565248808896.png)

![1565248868738](assets/1565248868738.png)

![1565249030385](assets/1565249030385.png)

![1565249280650](assets/1565249280650.png)

**本节小结**

![1565249297402](assets/1565249297402.png)

***
## 十二、死锁的概念
**知识总览**

![1565249978225](assets/1565249978225.png)

![1565307324781](assets/1565307324781.png)

* 死锁: 如果一个进程集合里面的每个进程都在等待只能由这个集合中的其他一个进程（包括他自身）才能引发的事件，这种情况就是死锁。

![1565307354230](assets/1565307354230.png)

![1565307377909](assets/1565307377909.png)

* 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
* 不可剥夺：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
* 请求和保持：已经得到了某个资源的进程可以再请求新的资源。
* 循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

![1565308929135](assets/1565308929135.png)

**本节小结**

![1565309314853](assets/1565309314853.png)

***
## 十三、死锁的处理策略—预防死锁
**知识总览**

![1565309347427](assets/1565309347427.png)

![1565310189361](assets/1565310189361.png)

![1565310212866](assets/1565310212866.png)

![1565310770571](assets/1565310770571.png)

![1565310789425](assets/1565310789425.png)

**本节小结**

![1565310943347](assets/1565310943347.png)

***
## 十四、死锁的处理策略—避免死锁(银行家算法)
**知识总览**

![1565311107760](assets/1565311107760.png)

![1565311129619](assets/1565311129619.png)

![1565311262841](assets/1565311262841.png)

![1565311688801](assets/1565311688801.png)

* 注意安全状态是只要找到一个安全序列即可。

**不会发生死锁的举例**

![1565311904800](assets/1565311904800.png)

![1565311934216](assets/1565311934216.png)

![1565312054458](assets/1565312054458.png)

**可能发生死锁的情况举例**

![1565312383504](assets/1565312383504.png)

**实现银行家算法**

![1565312416553](assets/1565312416553.png)

***
## 十五、死锁的处理策略—死锁的检测与解除
**知识总览**

![1565312616767](assets/1565312616767.png)

![1565312636547](assets/1565312636547.png)

![1565312667296](assets/1565312667296.png)

![1565312694837](assets/1565312694837.png)

![1565312717623](assets/1565312717623.png)

**本节小结**

![1565312738111](assets/1565312738111.png)

***
